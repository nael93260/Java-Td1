Exercice 1

2) ça compléte automatiquement en inscrivant system.out.println
3) ça propose la méthode to String
4) ça propose la methode main 
5) ça propose d'implémenter le constructeur de la classe. Ensuite si on tap set et ctrl + space ça nous propose d'implementer un setter pour le champs foo créer précédemment.
6) ça permet de refractor  le nom de la classe (renommer le nom de classe partout où elle est utilisée) et idem sur le champs foo également (renommer le nom du champs  partout où il est utilisé)
7) Ctrl + clic sur une classe permet de se rendre à la déclaration de classe , donc ici en le faisant sur String on se rend à la déclaration de  la classe String avec les méthodes qu'elle implémente.

Exercice 2

1) car on utilise le constrcuteur par défaut
2) il y a une erreur, on nous dis que les champs Point.x et et Point.y ne sont pas visibles. Pour corriger ça soit on met les champs x et y en public ou sinon on créer des getter pour recuperer leur valeurs et il faudra ecrire p.get(x) et p.get(y) dans le sysout.
3) car un attribut peut être utilisé dans le fonctionnement interne d'une classe et peut être amené  à fournir sa valeur à d'autres classes sans pour autant permettre à ces dernières de la modifier. Il est possible que certaine valeur dans un programme ne doivent surtout pas être modifier. Les mettres en private permet donc de se protéger contre d'eventuelle erreur de nous même (par oublis) ou encore par les autre developpeur voir contre des potentiels utilisateurs dans le cas d'une api distribuée.
4) C'est un getter qui permet d 'acceder à une variable en private. On doit l'utiliser ici pour régler le problème de la question 2). 
5) Comme on à initialisé un constrcuteur avecd es parramètre, le constructeur par défaut n'est plus disponible.
6) Il y a une erreur , eclipse ne comprend pas si c'est l'attribut x et y de la classe Point à qui on souhaite affecté la valeur de x et y passé en parramètre du constructeur ou bien l'inverse. C'est pour ça qu'il faut préciser This.x et this.y pour bien faire références aux attributs de la classe.
7) Il faudrait créer un champs statique dans la classe Point qu'on incrémenterais dans le constructeur ( à chaque fois qu'on nouveau point est créer).
8) Le compilateur sait quel constructeur appelé en fonction des parametres utilisés. Dans notre exemple actuel , si on fait appel au constructeur en prenant en parramètre les coordonées du point le compilateur va chercher le constructeur qui prend en parramétre 2 entiers , si on fais appel au constructeur en prenant en parametre un point il va chercher le constructeur qui attent un object de type Point en parramètre. 
9)on écris return "(" + this.x + "," + this.y + ")"; dans la méthode toString

Exercice 3
1) Le code affiche true puis false. Car la comparaison entre les objets se fais par rapport à l'adresse mémoire et non les valeurs des champs. En effet lorqu'on fais p2 = p1 ; p2 et p1 pointe désormais vers la même adresse mémoire. Tandis que p1 et p3 malgrés qu'ils aient les mêmes valeurs de champs ont une adresse différente.
3) Le problème est que le point p3 n'est pas repéré dans la liste alors qu'il a les même coordonées que le point p2 quui lui a les mêmes coordonées que le point p1. En partant du principe que 2 points qui ont les mêmes coordonées doivent être considérés comme identiques. On voudrais voir le même index pour p3 dans la liste que pour p2 (car mêmes coordonnées). Dans index of la méthode qui nous interessent qui est appelée est ".equals". Il nous suffit donc de modifier cette méthode dans la classe Point afin que lorsque qu'il s'agit d'un object de type Point on return true a .equals si les 2 points ont les mêmes coordonées.  

Exercice 4
2) On a une erreur de type ArrayIndexOutOfBoundsException. Pour éviter ce problème il faudrait ajouter une condition pour veriffier si la liste est pleine avant d'inserer un nouveau Point avec la méthode add. Si elle est pleine on pourra renvoyer une IllegalStateException avec un msg d'erreur approprié ; exemple "liste pleine".
5) Cela depend de la condition du if dans la boucle for each de notre méthode contains; si on verifie que un point p1 passé en parrametre est contenu dans notre liste en faisant p1 .equals p (p représentant tous les points de notre liste) alors on aura une erreur de type "java.lang.NullException" car on appelle une méthode sur un objet null. Si on inverse le .equals en faisant p.equals(p1) alors cela renverra false.
Si on fait add(null) avant ça va bien ajouter le point dans la liste mais si on essaye de parcourir notre liste on aura forcement une erreur de type "java.lang.NullException" car la méthode .equals ne peut pas être appelée sur un objet null.
6)

Exercice 5